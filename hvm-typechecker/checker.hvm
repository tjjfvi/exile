// Term.top_as_rec : _
(Term.top_as_rec) = (Term.rec @top (Term.lam (Term.bot) @x top))

// Term.bot_as_rec : _
(Term.bot_as_rec) = (Term.rec @bot (Term.lam (Term.top) @x bot))

// Checker.Result.to_bool (l: (Checker.Result)) : (Bool)
(Checker.Result.to_bool (Checker.Result.ok)) = (Bool.true)
(Checker.Result.to_bool b) = (Bool.false)

// Checker.Result.and (l: (Checker.Result)) (r: (Checker.Result)) : (Checker.Result)
(Checker.Result.and (Checker.Result.err state) r) = (Checker.Result.err state)
(Checker.Result.and l (Checker.Result.err state)) = (Checker.Result.err state)
(Checker.Result.and l r) = (Checker.Result.ok)

// Checker.Result.or (l: (Checker.Result)) (r: (Checker.Result)) : (Checker.Result)
(Checker.Result.or (Checker.Result.err state) (Checker.Result.err state2)) = (Checker.Result.err state)
(Checker.Result.or l r) = (Checker.Result.ok)

// Checker.Result.to_string (l: (Checker.Result)) : (String)
(Checker.Result.to_string (Checker.Result.ok)) = "Checking successful"
(Checker.Result.to_string (Checker.Result.err st)) = (String.flatten (List.cons "Checking not successful. Traceback: " (List.cons (String.newline) (List.cons (State.print_traceback st) (List.nil)))))

// Judgement.show (j: (Judgement)) : (String)
(Judgement.show (Judgement.Instance term type)) = (String.flatten (List.cons (Term.show (State.empty) term) (List.cons " : " (List.cons (Term.show (State.empty) type) (List.nil)))))
(Judgement.show (Judgement.Equal l r)) = (String.flatten (List.cons (Term.show (State.empty) l) (List.cons " == " (List.cons (Term.show (State.empty) r) (List.nil)))))
(Judgement.show (Judgement.Subtype sub sup)) = (String.flatten (List.cons (Term.show (State.empty) sub) (List.cons " <= " (List.cons (Term.show (State.empty) sup) (List.nil)))))

// State.Traceback.Entry.show (entry: (State.Traceback.Entry)) : (String)
(State.Traceback.Entry.show (State.Traceback.Entry.comment msg)) = (String.flatten (List.cons "// " (List.cons msg (List.nil))))
(State.Traceback.Entry.show (State.Traceback.Entry.judgement j)) = (Judgement.show j)

// State.empty : _
(State.empty) = (State.new 0 (List.nil))

// State.set_depth (st: (State)) (d: U60) : (State)
(State.set_depth (State.new depth tb) new_depth) = (State.new new_depth tb)

// State.get_depth (st: (State)) : U60
(State.get_depth (State.new depth tb)) = depth

// State.add_traceback (st: (State)) (entry: (State.Traceback.Entry)) : (State)
(State.add_traceback (State.new depth traceback) entry) = (State.new depth (List.append traceback entry))

// State.with_traceback -(t: Type) (st: (State)) (judgement: (Judgement)) (cont: (_: (State)) t) : t
(State.with_traceback st judgement cont) = (cont (State.add_traceback st (State.Traceback.Entry.judgement judgement)))

// State.with_comment -(t: Type) (st: (State)) (err: (String)) (cont: (_: (State)) t) : t
(State.with_comment st err cont) = (cont (State.add_traceback st (State.Traceback.Entry.comment err)))

// State.print_traceback (st: (State)) : (String)
(State.print_traceback (State.new x0_ (List.nil))) = ""
(State.print_traceback (State.new d (List.cons head tail))) = (String.flatten (List.cons (State.Traceback.Entry.show head) (List.cons (String.newline) (List.cons (State.print_traceback (State.new d tail)) (List.nil)))))

// State.new_forall -(t: Type) (st: (State)) (cont: (_: (State)) (_: (Term)) t) : t
(State.new_forall st cont) = let old_depth = (State.get_depth st); let new_state = (State.set_depth st (+ old_depth 1)); ((cont new_state) (Term.forall old_depth))

// Checker.instance (st: (State)) (term: (Term)) (type: (Term)) : (Checker.Result)
(Checker.instance st term type) = (State.with_traceback st (Judgement.Instance term type) @st (Checker.instance.go st term type))

// Checker.instance.go (st: (State)) (term: (Term)) (type: (Term)) : (Checker.Result)
(Checker.instance.go st term (Term.top)) = (Checker.Result.ok)
(Checker.instance.go st term (Term.bot)) = (State.with_comment st "No term is an instance of the bottom type" @st (Checker.Result.err st))
(Checker.instance.go st (Term.top) x) = (State.with_comment st "The top type is only an instance of the top type" @st (Checker.Result.err st))
(Checker.instance.go st (Term.bot) x) = (State.with_comment st "The bottom type is only an instance of the top type" @st (Checker.Result.err st))
(Checker.instance.go st (Term.lam t.type t.body) (Term.lam y.type y.body)) = (State.new_forall st @st @x let x = (Term.instance_bound x y.type); (Checker.Result.and (Checker.subtype st y.type t.type) (Checker.instance st (t.body x) (y.body x))))
(Checker.instance.go st (Term.rec body) t) = (Checker.instance.go st (body (Term.rec body)) t)
(Checker.instance.go st t (Term.rec body)) = (Checker.instance.go st t (body (Term.rec body)))
(Checker.instance.go st (Term.self body) type) = (State.new_forall st @st @x let x = (Term.instance_bound x (Term.self body)); (Checker.instance st (body x) type))
(Checker.instance.go st term (Term.self body)) = (Checker.instance st term (body term))
(Checker.instance.go st (Term.instance_bound instance subtype) supertype) = (Checker.Result.or (Checker.subtype st subtype supertype) (Checker.instance st instance supertype))
(Checker.instance.go st instance (Term.instance_bound type typetype)) = (Checker.instance st instance type)
(Checker.instance.go st (Term.forall x0_) type) = (State.with_comment st "Only the top type is the type of any term" @st (Checker.Result.err st))
(Checker.instance.go st a (Term.apply b c)) = (State.with_comment st (String.cons 67 (String.cons 97 (String.cons 110 (String.cons 39 "t decide if a term is an instance of an application")))) @st (Checker.Result.err st))

// Checker.subtype (st: (State)) (term: (Term)) (type: (Term)) : (Checker.Result)
(Checker.subtype st term type) = (State.with_traceback st (Judgement.Subtype term type) @st (Checker.subtype.go st term type))

// Checker.subtype.go (st: (State)) (term: (Term)) (type: (Term)) : (Checker.Result)
(Checker.subtype.go st (Term.forall a) (Term.forall b)) = (U60.if (== a b) (Checker.Result.ok) (State.with_comment st (String.cons 84 (String.cons 104 (String.cons 101 (String.cons 115 (String.cons 101 (String.cons 32 (String.cons 116 (String.cons 119 (String.cons 111 (String.cons 32 (String.cons 116 (String.cons 101 (String.cons 114 (String.cons 109 (String.cons 115 (String.cons 32 (String.cons 97 (String.cons 114 (String.cons 101 (String.cons 32 (String.cons 110 (String.cons 111 (String.cons 116 (String.cons 32 (String.cons 101 (String.cons 113 (String.cons 117 (String.cons 97 (String.cons 108 (String.cons 44 (String.cons 32 (String.cons 115 (String.cons 111 (String.cons 32 (String.cons 116 (String.cons 104 (String.cons 101 (String.cons 121 (String.cons 39 "re not a subtype of each other every time"))))))))))))))))))))))))))))))))))))))) @st (Checker.Result.err st)))
(Checker.subtype.go st term (Term.top)) = (Checker.Result.ok)
(Checker.subtype.go st (Term.bot) x) = (Checker.Result.ok)
(Checker.subtype.go st term (Term.bot)) = (Checker.Result.err st)
(Checker.subtype.go st (Term.top) x) = (Checker.Result.err st)
(Checker.subtype.go st (Term.lam t.type t.body) (Term.lam y.type y.body)) = (State.new_forall st @st @x let x = (Term.instance_bound x y.type); (Checker.Result.and (Checker.subtype st y.type t.type) (Checker.subtype st (t.body x) (y.body x))))
(Checker.subtype.go st (Term.rec st.body) (Term.rec sp.body)) = (State.new_forall st @st @y (State.new_forall st @st @x let x = (Term.subtype_bound x y); (Checker.subtype st (st.body x) (sp.body y))))
(Checker.subtype.go st (Term.rec st.body) type) = (Checker.subtype st (st.body (Term.rec st.body)) type)
(Checker.subtype.go st term (Term.rec sp.body)) = (Checker.subtype st term (sp.body (Term.rec sp.body)))
(Checker.subtype.go st (Term.forall a) b) = (State.with_comment st "Only the top type is the supertype of all types" @st (Checker.Result.err st))
(Checker.subtype.go st (Term.instance_bound a b) c) = (Checker.subtype st a c)
(Checker.subtype.go st (Term.apply a b) c) = (State.with_comment st (String.cons 67 (String.cons 97 (String.cons 110 (String.cons 39 "t decide. Falling back to equality.")))) @st (Checker.equal st (Term.apply a b) c))

// Checker.eval.app (fn: (Term)) (arg: (Term)) : (Term)
(Checker.eval.app (Term.lam t f) arg) = (Checker.eval (f arg))
(Checker.eval.app (Term.rec f) arg) = (Checker.eval (Term.apply (f (Term.rec f)) arg))
(Checker.eval.app (Term.instance_bound a b) arg) = (Checker.eval (Term.instance_bound (Checker.eval (Term.apply a arg)) (Checker.eval (Term.apply b arg))))
(Checker.eval.app f arg) = (Term.apply f arg)

// Checker.eval (x: (Term)) : (Term)
(Checker.eval (Term.apply f arg)) = (Checker.eval.app (Checker.eval f) (Checker.eval arg))
(Checker.eval (Term.lam type body)) = (Term.lam (Checker.eval type) @arg (Checker.eval (body arg)))
(Checker.eval (Term.rec body)) = (Term.rec @arg (Checker.eval (body arg)))
(Checker.eval (Term.self body)) = (Term.self @arg (Checker.eval (body arg)))
(Checker.eval (Term.instance_bound a (Term.top))) = (Checker.eval a)
(Checker.eval (Term.subtype_bound a (Term.top))) = (Checker.eval a)
(Checker.eval (Term.instance_bound a b)) = (Term.instance_bound (Checker.eval a) (Checker.eval b))
(Checker.eval (Term.subtype_bound a b)) = (Term.subtype_bound (Checker.eval a) (Checker.eval b))
(Checker.eval e) = e

// Checker.equal (st: (State)) (l: (Term)) (r: (Term)) : (Checker.Result)
(Checker.equal st l r) = (State.with_traceback st (Judgement.Equal l r) @st (Checker.equal.go st l r))

// Checker.equal.go (st: (State)) (left: (Term)) (right: (Term)) : (Checker.Result)
(Checker.equal.go st (Term.apply a b) (Term.apply c d)) = (Checker.Result.and (Checker.equal st a c) (Checker.equal st b d))
(Checker.equal.go st (Term.forall a) (Term.forall b)) = (U60.if (== a b) (Checker.Result.ok) (State.with_comment st "These two terms might not be equal" @st (Checker.Result.err st)))
(Checker.equal.go st (Term.lam l.type l.body) (Term.lam r.type r.body)) = (State.new_forall st @st @x (Checker.Result.and (Checker.equal st l.type r.type) (Checker.equal st (l.body x) (r.body x))))
(Checker.equal.go st (Term.self l.body) (Term.self r.body)) = (State.new_forall st @st @x (Checker.equal st (l.body x) (r.body x)))
(Checker.equal.go st (Term.instance_bound l.instance l.type) (Term.instance_bound r.instance r.type)) = (Checker.Result.and (Checker.equal st l.instance r.instance) (Checker.equal st l.type r.type))
(Checker.equal.go st (Term.top) (Term.top)) = (Checker.Result.ok)
(Checker.equal.go st (Term.bot) (Term.bot)) = (Checker.Result.ok)
(Checker.equal.go st (Term.top) (Term.bot)) = (Checker.Result.err "* != !")
(Checker.equal.go st (Term.bot) (Term.top)) = (Checker.Result.err "* != !")
(Checker.equal.go st (Term.top) a) = (Checker.equal st (Term.top_as_rec) a)
(Checker.equal.go st a (Term.top)) = (Checker.equal st a (Term.top_as_rec))
(Checker.equal.go st (Term.bot) a) = (Checker.equal st (Term.bot_as_rec) a)
(Checker.equal.go st a (Term.bot)) = (Checker.equal st a (Term.bot_as_rec))
(Checker.equal.go st (Term.rec l.body) (Term.rec r.body)) = (State.new_forall st @st @x (Checker.equal.go st (l.body (r.body x)) (r.body (l.body x))))
(Checker.equal.go st a (Term.rec r.body)) = (Checker.equal.go st a (r.body (Term.rec r.body)))
(Checker.equal.go st (Term.rec l.body) b) = (Checker.equal.go st (l.body (Term.rec l.body)) b)
(Checker.equal.go st a b) = (State.with_comment st "Terms are not equal (or the code for checking this was not implemented)" @st (Checker.Result.err st))

// Bool.if -(p: Type) (a: (Bool)) (t: p) (f: p) : p
(Bool.if (Bool.true) t f) = t
(Bool.if (Bool.false) t f) = f

// U60.if -(p: Type) (a: U60) (t: p) (f: p) : p
(U60.if 0 t f) = f
(U60.if x t f) = t

// Bool.and (a: (Bool)) (b: (Bool)) : _
(Bool.and a b) = (Bool.if a b (Bool.false))

// Bool.or (a: (Bool)) (b: (Bool)) : _
(Bool.or a b) = (Bool.if a (Bool.true) b)

// U60.to_string (n: U60) : (String)
(U60.to_string n) = (U60.if (< n 10) (String.cons (+ 48 n) "") (String.concat (U60.to_string (/ n 10)) (String.cons (+ 48 (% n 10)) "")))

// Bool.to_string (a: (Bool)) : (String)
(Bool.to_string (Bool.true)) = "Bool.true"
(Bool.to_string (Bool.false)) = "Bool.false"

// String.newline : _
(String.newline) = (String.cons 10 "")

// List.append -(t: Type) (list: (List t)) (item: t) : (List t)
(List.append (List.nil) item) = (List.cons item (List.nil))
(List.append (List.cons head tail) item) = (List.cons head (List.append tail item))

// String.concat (a: (String)) (b: (String)) : (String)
(String.concat (String.cons a b) c) = (String.cons a (String.concat b c))
(String.concat "" c) = c

// String.flatten (a: (List (String))) : (String)
(String.flatten (List.cons a (List.cons b c))) = (String.flatten (List.cons (String.concat a b) c))
(String.flatten (List.cons a (List.nil))) = a
(String.flatten (List.nil)) = ""

// Term.show (st: (State)) (term: (Term)) : (String)
(Term.show st (Term.lam type body)) = let type_s = (Term.show st type); let var = (String.flatten (List.cons "x" (List.cons (U60.to_string (State.get_depth st)) (List.nil)))); (State.new_forall st @st @x let x = (Term.attach x var); (Bool.if (Checker.Result.to_bool (Checker.equal st type (Term.top))) (String.flatten (List.cons (String.cons 955 "") (List.cons var (List.cons " " (List.cons (Term.show st (body x)) (List.nil)))))) (String.flatten (List.cons (String.cons 955 "(") (List.cons var (List.cons ": " (List.cons type_s (List.cons ") " (List.cons (Term.show st (body x)) (List.nil))))))))))
(Term.show st (Term.rec body)) = let var = (String.flatten (List.cons "x" (List.cons (U60.to_string (State.get_depth st)) (List.nil)))); (State.new_forall st @st @x let x = (Term.attach x var); (String.flatten (List.cons (String.cons 181 "") (List.cons var (List.cons " " (List.cons (Term.show st (body x)) (List.nil)))))))
(Term.show st (Term.self body)) = let var = (String.flatten (List.cons "x" (List.cons (U60.to_string (State.get_depth st)) (List.nil)))); (State.new_forall st @st @x let x = (Term.attach x var); (String.flatten (List.cons (String.cons 958 "") (List.cons var (List.cons " " (List.cons (Term.show st (body x)) (List.nil)))))))
(Term.show st (Term.attach (Term.forall a) s)) = s
(Term.show st (Term.top)) = "*"
(Term.show st (Term.bot)) = "!"
(Term.show st (Term.apply a b)) = (String.flatten (List.cons "(" (List.cons (Term.show st a) (List.cons " " (List.cons (Term.show st b) (List.cons ")" (List.nil)))))))
(Term.show st (Term.forall uid)) = (String.flatten (List.cons "any" (List.cons (U60.to_string uid) (List.nil))))
(Term.show st (Term.instance_bound term type)) = (String.flatten (List.cons (Term.show st term) (List.cons " :: " (List.cons (Term.show st type) (List.nil)))))
(Term.show st (Term.subtype_bound sub sup)) = (String.flatten (List.cons (Term.show sub sup) (List.cons " <= " (List.cons (Term.show sub sup) (List.nil)))))

// Main2 : _
(Main2) = let st = (State.empty); (State.new_forall st @st @t (State.new_forall st @st @u (State.new_forall st @st @v let v = (Term.instance_bound v u); (Checker.instance st (Term.lam t @x v) (Term.lam t @x u)))))

// DebugCheck (a: (Term)) (b: (Term)) : (String)
(DebugCheck a b) = let st = (State.empty); (String.flatten (List.cons (Term.show st a) (List.cons ": " (List.cons (Term.show st b) (List.cons " = " (List.cons (Checker.Result.to_string (Checker.instance st (Checker.eval a) (Checker.eval b))) (List.nil)))))))

// DebugEqual (a: (Term)) (b: (Term)) : (String)
(DebugEqual a b) = let st = (State.empty); (String.flatten (List.cons (Term.show st a) (List.cons " == " (List.cons (Term.show st b) (List.cons " = " (List.cons (Checker.Result.to_string (Checker.equal st (Checker.eval a) (Checker.eval b))) (List.nil)))))))

// Sample : _
(Sample) = let st = (State.empty); (String.flatten (List.cons (DebugCheck (Test.Bool.true) (Test.Bool)) (List.cons (String.newline) (List.cons (DebugCheck (Test.Bool.true) (Test.Unit)) (List.cons (String.newline) (List.cons (DebugCheck (Test.Unit.new) (Test.Unit)) (List.cons (String.newline) (List.cons (DebugCheck (Test.Unit.new) (Test.Bool)) (List.cons (String.newline) (List.cons (DebugCheck (Test.Equal.refl) (Test.Equal.refl.type)) (List.cons (String.newline) (List.cons (DebugEqual (Term.top) (Term.top_as_rec)) (List.cons (String.newline) (List.nil))))))))))))))

// Main3 : _
(Main3) = let st = (State.empty); (State.new_forall st @st @typ (State.new_forall st @st @t (State.new_forall st @st @u let t = (Term.instance_bound t typ); let t = (Term.instance_bound u typ); (Checker.instance (State.empty) (Checker.eval (Term.apply (Term.apply (Test.Equal.refl) typ) t)) (Checker.eval (Term.apply (Term.apply (Term.apply (Test.Equal) typ) t) u))))))

// Main4 : _
(Main4) = (Checker.Result.to_string (Checker.instance.go (State.empty) (Test.Bool.true) (Test.Unit)))

// Main5 : _
(Main5) = (Sample)

// Main : _
(Main) = (DebugEqual (Term.top) (Term.top_as_rec))

Test.Bool.true = (Checker.eval (Term.lam (Term.top) λx0 (Checker.eval (Term.lam (Term.top) λx1 (Checker.eval (Term.lam (Term.top) λx2 x1))))))
Test.Bool = (Term.rec λx0 (Term.self λx1 (Checker.eval (Term.lam (Checker.eval (Term.lam x0 λx2 (Term.top))) λx2 (Checker.eval (Term.lam (Term.apply x2 (Checker.eval (Term.lam (Term.top) λx3 (Checker.eval (Term.lam (Term.top) λx4 (Checker.eval (Term.lam (Term.top) λx5 x4))))))) λx3 (Checker.eval (Term.lam (Term.apply x2 (Checker.eval (Term.lam (Term.top) λx4 (Checker.eval (Term.lam (Term.top) λx5 (Checker.eval (Term.lam (Term.top) λx6 x5))))))) λx4 (Term.apply x2 x1)))))))))
Test.Unit.new = (Checker.eval (Term.lam (Term.top) λx0 (Checker.eval (Term.lam (Term.top) λx1 x1))))
Test.Unit = (Term.rec λx0 (Term.self λx1 (Checker.eval (Term.lam (Checker.eval (Term.lam x0 λx2 (Term.top))) λx2 (Checker.eval (Term.lam (Term.apply x2 (Checker.eval (Term.lam (Term.top) λx3 (Checker.eval (Term.lam (Term.top) λx4 x4))))) λx3 (Term.apply x2 x1)))))))
Test.Equal = (Checker.eval (Term.lam (Term.top) λx0 (Checker.eval (Term.lam x0 λx1 (Checker.eval (Term.lam x0 λx2 (Checker.eval (Term.lam (Checker.eval (Term.lam x0 λx3 (Term.top))) λx3 (Checker.eval (Term.lam (Term.apply x3 x1) λx4 (Term.apply x3 x2)))))))))))
Test.Equal.refl = (Checker.eval (Term.lam (Term.top) λx0 (Checker.eval (Term.lam x0 λx1 (Checker.eval (Term.lam (Checker.eval (Term.lam x0 λx2 (Term.top))) λx2 (Checker.eval (Term.lam (Term.apply x2 x1) λx3 x3))))))))
Test.Equal.refl.type = (Checker.eval (Term.lam (Term.top) λx0 (Checker.eval (Term.lam x0 λx1 (Checker.eval (Term.lam (Checker.eval (Term.lam x0 λx2 (Term.top))) λx2 (Checker.eval (Term.lam (Term.apply x2 x1) λx3 (Term.apply x2 x1)))))))))
