// State : _
(State) = 0

// State.set_depth (st: (State)) (d: U60) : _
(State.set_depth st d) = d

// State.get_depth (st: (State)) : U60
(State.get_depth st) = st

// State.new : (State)
(State.new) = 0

// State.new_forall -(t: Type) (st: (State)) (cont: (_: (State)) (_: (Term)) t) : t
(State.new_forall st cont) = let old_depth = (State.get_depth st); let new_state = (State.set_depth st (+ old_depth 1)); ((cont new_state) (Term.forall old_depth))

// Checker.instance (st: (State)) (term: (Term)) (type: (Term)) : (Bool)
(Checker.instance st term (Term.top)) = (Bool.true)
(Checker.instance st term (Term.bot)) = (Bool.false)
(Checker.instance st (Term.top) x) = (Bool.false)
(Checker.instance st (Term.bot) x) = (Bool.false)
(Checker.instance st (Term.lam t.type t.body) (Term.lam y.type y.body)) = (State.new_forall st @st @x let x = (Term.instance_bound x y.type); (Bool.and (Checker.subtype st y.type t.type) (Checker.instance st (t.body x) (y.body x))))
(Checker.instance st (Term.rec body) t) = (Checker.instance st (body (Term.rec body)) t)
(Checker.instance st t (Term.rec body)) = (Checker.instance st t (body (Term.rec body)))
(Checker.instance st (Term.self body) type) = (State.new_forall st @st @x let x = (Term.instance_bound x (Term.self body)); (Checker.instance st (body x) type))
(Checker.instance st term (Term.self body)) = (Checker.instance st term (body term))
(Checker.instance st (Term.instance_bound instance subtype) supertype) = (Bool.or (Checker.subtype st subtype supertype) (Checker.instance st instance supertype))
(Checker.instance st instance (Term.instance_bound type typetype)) = (Checker.instance st instance type)
(Checker.instance st (Term.forall x0_) type) = (Bool.false)
(Checker.instance st a (Term.apply b c)) = (Bool.false)

// Checker.subtype (st: (State)) (term: (Term)) (type: (Term)) : (Bool)
(Checker.subtype st (Term.forall a) (Term.forall b)) = (U60.if (== a b) (Bool.true) (Bool.false))
(Checker.subtype st term (Term.top)) = (Bool.true)
(Checker.subtype st (Term.bot) x) = (Bool.true)
(Checker.subtype st term (Term.bot)) = (Bool.false)
(Checker.subtype st (Term.top) x) = (Bool.false)
(Checker.subtype st (Term.lam t.type t.body) (Term.lam y.type y.body)) = (State.new_forall st @st @x let x = (Term.instance_bound x y.type); (Bool.and (Checker.subtype st y.type t.type) (Checker.subtype st (t.body x) (y.body x))))
(Checker.subtype st (Term.rec st.body) (Term.rec sp.body)) = (State.new_forall st @st @y (State.new_forall st @st @x let x = (Term.subtype_bound x y); (Checker.subtype st (st.body x) (sp.body y))))
(Checker.subtype st (Term.rec st.body) type) = (Checker.subtype st (st.body (Term.rec st.body)) type)
(Checker.subtype st term (Term.rec sp.body)) = (Checker.subtype st term (sp.body (Term.rec sp.body)))
(Checker.subtype st (Term.forall a) b) = (Bool.false)
(Checker.subtype st (Term.instance_bound a b) c) = (Checker.subtype st a c)
(Checker.subtype st (Term.apply a b) c) = (Checker.equal st (Term.apply a b) c)

// Checker.eval.app (fn: (Term)) (arg: (Term)) : (Term)
(Checker.eval.app (Term.lam t f) arg) = (Checker.eval (f arg))
(Checker.eval.app (Term.rec f) arg) = (Checker.eval (Term.apply (f (Term.rec f)) arg))
(Checker.eval.app (Term.instance_bound a b) arg) = (Checker.eval (Term.instance_bound (Checker.eval (Term.apply a arg)) (Checker.eval (Term.apply b arg))))
(Checker.eval.app f arg) = (Term.apply f arg)

// Checker.eval (x: (Term)) : (Term)
(Checker.eval (Term.apply f arg)) = (Checker.eval.app (Checker.eval f) (Checker.eval arg))
(Checker.eval (Term.lam type body)) = (Term.lam (Checker.eval type) @arg (Checker.eval (body arg)))
(Checker.eval (Term.rec body)) = (Term.rec @arg (Checker.eval (body arg)))
(Checker.eval (Term.self body)) = (Term.self @arg (Checker.eval (body arg)))
(Checker.eval (Term.instance_bound a (Term.top))) = (Checker.eval a)
(Checker.eval (Term.subtype_bound a (Term.top))) = (Checker.eval a)
(Checker.eval (Term.instance_bound a b)) = (Term.instance_bound (Checker.eval a) (Checker.eval b))
(Checker.eval (Term.subtype_bound a b)) = (Term.subtype_bound (Checker.eval a) (Checker.eval b))
(Checker.eval e) = e

// Checker.equal (st: (State)) (left: (Term)) (right: (Term)) : (Bool)
(Checker.equal st (Term.apply a b) (Term.apply c d)) = (Bool.and (Checker.equal st a c) (Checker.equal st b d))
(Checker.equal st (Term.forall a) (Term.forall b)) = (U60.if (== a b) (Bool.true) (Bool.false))
(Checker.equal st (Term.lam l.type l.body) (Term.lam r.type r.body)) = (State.new_forall st @st @x (Bool.and (Checker.equal st l.type r.type) (Checker.equal st (l.body x) (r.body x))))
(Checker.equal st (Term.self l.body) (Term.self r.body)) = (State.new_forall st @st @x (Checker.equal st (l.body x) (r.body x)))
(Checker.equal st (Term.instance_bound l.instance l.type) (Term.instance_bound r.instance r.type)) = (Bool.and (Checker.equal st l.instance r.instance) (Checker.equal st l.type r.type))
(Checker.equal st (Term.top) (Term.top)) = (Bool.true)
(Checker.equal st (Term.bot) (Term.bot)) = (Bool.true)
(Checker.equal st (Term.rec l.body) (Term.rec r.body)) = (State.new_forall st @st @x (Checker.equal st (l.body (r.body x)) (r.body (l.body x))))

// Bool.if -(p: Type) (a: (Bool)) (t: p) (f: p) : p
(Bool.if (Bool.true) t f) = t
(Bool.if (Bool.false) t f) = f

// U60.if -(p: Type) (a: U60) (t: p) (f: p) : p
(U60.if 0 t f) = f
(U60.if x t f) = t

// Bool.and (a: (Bool)) (b: (Bool)) : _
(Bool.and a b) = (Bool.if a b (Bool.false))

// Bool.or (a: (Bool)) (b: (Bool)) : _
(Bool.or a b) = (Bool.if a (Bool.true) b)

// Main2 : _
(Main2) = let st = (State.new); (State.new_forall st @st @t (State.new_forall st @st @u (State.new_forall st @st @v let v = (Term.instance_bound v u); (Checker.instance st (Term.lam t @x v) (Term.lam t @x u)))))

// Main3 : _
(Main3) = let st = (State.new); (State.new_forall st @st @typ (State.new_forall st @st @t let t = (Term.instance_bound t typ); (Checker.instance (State.new) (Checker.eval (Term.apply (Term.apply (Test.Equal.refl) typ) t)) (Checker.eval (Term.apply (Term.apply (Term.apply (Test.Equal) typ) t) t)))))

// Main : _
(Main) = (Main3)

Test.Bool.true = (Checker.eval (Term.lam (Term.top) λx0 (Checker.eval (Term.lam (Term.top) λx1 (Checker.eval (Term.lam (Term.top) λx2 x1))))))
Test.Bool = (Term.rec λx0 (Term.self λx1 (Checker.eval (Term.lam (Checker.eval (Term.lam x0 λx2 (Term.top))) λx2 (Checker.eval (Term.lam (Term.apply x2 (Checker.eval (Term.lam (Term.top) λx3 (Checker.eval (Term.lam (Term.top) λx4 (Checker.eval (Term.lam (Term.top) λx5 x4))))))) λx3 (Checker.eval (Term.lam (Term.apply x2 (Checker.eval (Term.lam (Term.top) λx4 (Checker.eval (Term.lam (Term.top) λx5 (Checker.eval (Term.lam (Term.top) λx6 x5))))))) λx4 (Term.apply x2 x1)))))))))
Test.Unit.new = (Checker.eval (Term.lam (Term.top) λx0 (Checker.eval (Term.lam (Term.top) λx1 x1))))
Test.Unit = (Term.rec λx0 (Term.self λx1 (Checker.eval (Term.lam (Checker.eval (Term.lam x0 λx2 (Term.top))) λx2 (Checker.eval (Term.lam (Term.apply x2 (Checker.eval (Term.lam (Term.top) λx3 (Checker.eval (Term.lam (Term.top) λx4 x4))))) λx3 (Term.apply x2 x1)))))))
Test.Equal = (Checker.eval (Term.lam (Term.top) λx0 (Checker.eval (Term.lam x0 λx1 (Checker.eval (Term.lam x0 λx2 (Checker.eval (Term.lam (Checker.eval (Term.lam x0 λx3 (Term.top))) λx3 (Checker.eval (Term.lam (Term.apply x3 x1) λx4 (Term.apply x3 x2)))))))))))
Test.Equal.refl = (Checker.eval (Term.lam (Term.top) λx0 (Checker.eval (Term.lam x0 λx1 (Checker.eval (Term.lam (Checker.eval (Term.lam x0 λx2 (Term.top))) λx2 (Checker.eval (Term.lam (Term.apply x2 x1) λx3 x3))))))))
Test.Equal.refl.type = (Checker.eval (Term.lam (Term.top) λx0 (Checker.eval (Term.lam x0 λx1 (Checker.eval (Term.lam (Checker.eval (Term.lam x0 λx2 (Term.top))) λx2 (Checker.eval (Term.lam (Term.apply x2 x1) λx3 (Term.apply x2 x1)))))))))
