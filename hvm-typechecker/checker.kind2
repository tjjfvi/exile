Term: Type
Term.top: Term
Term.lam (type: Option Term) (body: TermBody): Term
Term.rec (body: TermBody): Term
Term.self (body: TermBody): Term
Term.apply (fn: Term) (arg: Term): Term
Term.check (instance: Term) (type: Term): Term
Term.typeof (instance: Term): Term
Term.var (id: U60): Term
Term.error: Term
// Term.attach <t> (term: Term) (data: t): Term

HVM.log <a: Type> <r: Type> (logged: a) (result: r) {
  result
}

Term.replace (term: Term) (var: U60) (val: Term): Term
Term.replace Term.top _ _ = Term.top
Term.replace (Term.lam type body) var val = (Term.lam
	(Option.match type (x => Option.some (Term.replace x var val)) Option.none)
	(TermBody.replace body var val)
)
Term.replace (Term.rec body) var val = (Term.rec (TermBody.replace body var val))
Term.replace (Term.self body) var val = (Term.self (TermBody.replace body var val))
Term.replace (Term.apply a b) var val = (Term.apply (Term.replace a var val) (Term.replace b var val))
Term.replace (Term.check a b) var val = (Term.check (Term.replace a var val) (Term.replace b var val))
Term.replace (Term.typeof a) var val = (Term.typeof (Term.replace a var val))
Term.replace (Term.var id) var val = (U60.if (== id var) val (Term.var id))
Term.replace Term.error _ _ = Term.error

Term.uses_var (term: Term) (var: U60): Bool
Term.uses_var Term.top _ = Bool.false
Term.uses_var (Term.lam type body) var = (Bool.or
	(Option.match type (x => (Term.uses_var x var)) Bool.false)
	(TermBody.uses_var body var)
)
Term.uses_var (Term.rec body) var = (TermBody.uses_var body var)
Term.uses_var (Term.self body) var = (TermBody.uses_var body var)
Term.uses_var (Term.apply a b) var = (Bool.or (Term.uses_var a var) (Term.uses_var b var))
Term.uses_var (Term.check a b) var = (Bool.or (Term.uses_var a var) (Term.uses_var b var))
Term.uses_var (Term.typeof a) var = (Term.uses_var a var)
Term.uses_var (Term.var id) var = (U60.if (== id var) Bool.true Bool.false)
Term.uses_var Term.error _ = Bool.false

Term.next_var (term: Term): U60
Term.next_var Term.top = 0
Term.next_var (Term.lam type body) = (U60.max
	(Option.match type (x => (Term.next_var x)) 0)
	(TermBody.next_var body)
)
Term.next_var (Term.rec body) = (TermBody.next_var body)
Term.next_var (Term.self body) = (TermBody.next_var body)
Term.next_var (Term.apply a b) = (U60.max (Term.next_var a) (Term.next_var b))
Term.next_var (Term.check a b) = (U60.max (Term.next_var a) (Term.next_var b))
Term.next_var (Term.typeof a) = (Term.next_var a)
Term.next_var (Term.var id) = (+ id 1)
Term.next_var Term.error = 0

TermBody.next_var (body: TermBody): U60
TermBody.next_var (TermBody.new body.var body.term) = (U60.max body.var (Term.next_var body.term))

TermBody.uses_var (body: TermBody) (var: U60): Bool
TermBody.uses_var (TermBody.new body.var body.term) var = (Bool.or
	(U60.if (== body.var var) Bool.true Bool.false)
	(Term.uses_var body.term var)
)

TermBody: Type
TermBody.new (var: U60) (term: Term): TermBody

TermBody.apply (body: TermBody) (val: Term): Term
TermBody.apply (TermBody.new body.var body.term) val = Term.replace body.term body.var val

TermBody.replace (body: TermBody) (var: U60) (val: Term): TermBody
TermBody.replace (TermBody.new body.var body.term) var val =
  (U60.if (== body.var var)
    (TermBody.new body.var body.term) // shadowed
    (Bool.if (Term.uses_var val body.var)
      ( // alpha conversion
        let new_var = (U60.max (+ 1 var) (U60.max (Term.next_var body.term) (Term.next_var val)));
        (TermBody.new new_var (Term.replace (Term.replace body.term body.var (Term.var new_var)) var val))
      )
      (TermBody.new body.var (Term.replace body.term var val))
    )
  )

Judgement: Type
Judgement.equal (l: Term) (r: Term): Judgement
Judgement.reduce (term: Term): Judgement
Judgement.show (term: Judgement): String

TracebackEntry: Type
TracebackEntry.comment (comment: String): TracebackEntry
TracebackEntry.judgement (j: Judgement): TracebackEntry
TracebackEntry.show (tree: TracebackEntry): String

TracebackTree: Type
TracebackTree.leaf (term: Term): TracebackTree
TracebackTree.entry (entry: TracebackEntry) (child: TracebackTree): TracebackTree
TracebackTree.and (l: TracebackTree) (r: TracebackTree): TracebackTree
TracebackTree.or (l: TracebackTree) (r: TracebackTree): TracebackTree
TracebackTree.show (tree: TracebackTree): String

CheckResult: Type
CheckResult.new (term: Term) (tb: TracebackTree): CheckResult
CheckResult.with_comment (result: CheckResult) (comment: String): CheckResult
CheckResult.with_entry (result: CheckResult) (entry: TracebackEntry): CheckResult
CheckResult.with_reduce (result: CheckResult) (reduce: Term): CheckResult
CheckResult.with_equal (result: CheckResult) (l: Term) (r: Term): CheckResult
CheckResult.get_term (result: CheckResult): Term
CheckResult.show (result: CheckResult): String

Checker: Type
Checker.empty: Checker

Checker.reduce (checker: Checker) (term: Term): CheckResult
Checker.equal (checker: Checker) (l: Term) (r: Term): CheckResult
Checker.get_depth (checker: Checker): U60
Checker.new_forall <t> (checker: Checker) (cont: Checker -> Term -> t): t

// Util.is_equal (l: Term) (r: Term): Bool {
// 	Term.is_not_error (CheckResult.get_term (Checker.equal Checker.empty l r))
// }

Bool: Type
Bool.true: Bool
Bool.false: Bool
Bool.if <p> (a: Bool) (t: p) (f: p): p
Bool.if p Bool.true t f = t
Bool.if p Bool.false t f = f
U60.if <p> (a: U60) (t: p) (f: p): p
U60.if p 0 t f = f
U60.if p x t f = t
U60.max (a: U60) (b: U60): U60
U60.max a b = (U60.if (> a b) a b)
Bool.and (a: Bool) (b: Bool) { Bool.if a b Bool.false } 
Bool.or (a: Bool) (b: Bool) { Bool.if a Bool.true b }
U60.to_string (n: U60): String
U60.to_string n = (U60.if
	(< n 10)
	(String.cons (+ '0' n) String.nil)
	(String.concat (U60.to_string (/ n 10)) (String.cons (+ '0' (% n 10)) String.nil))
)
Bool.to_string (a: Bool): String
Bool.to_string Bool.true = "Bool.true"
Bool.to_string Bool.false = "Bool.false"
String.newline { String.cons 10 String.nil }

Option <t>: Type
Option.some <t> (value: t) : Option t
Option.none <t> : Option t

Option.match <t> <u> (opt: Option t) (some: t -> u) (none: u) : u
Option.match t u (Option.some val) some none = some val
Option.match t u Option.none some none = none

String: Type
String.cons (a: U60) (b: String): String
String.nil: String

List <t>: Type
List.cons <t> (a: t) (b: List t): List t
List.nil <t>: List t

List.append <t> (list: List t) (item: t): List t
List.append t List.nil item = List.cons item List.nil
List.append t (List.cons head tail) item = List.cons head (List.append t tail item)

List.len <t> (list: List t): U60
List.len t List.nil = 0
List.len t (List.cons _ l) = (+ (List.len l) 1)


String.concat (a: String) (b: String): String
String.concat (String.cons a b) c = (String.cons a (String.concat b c))
String.concat String.nil c = c

String.flatten (a: List String): String
String.flatten (List.cons a (List.cons b c)) = (String.flatten (List.cons (String.concat a b) c))
String.flatten (List.cons a List.nil) = a
String.flatten List.nil = ""

Term.show (term: Term): String
Term.show (Term.lam type (TermBody.new body.var body.term)) = 
	let var = String.flatten [ "x" (U60.to_string body.var) ]
  String.flatten [
		(String.flatten (Option.match type
			x => [ "λ(" var ": " (Term.show x) ")" ]
			[ "λ" var ]
		))
		" "
		(Term.show body.term)
  ]

Term.show (Term.rec (TermBody.new body.var body.term)) = 
	let var = String.flatten [ "x" (U60.to_string body.var) ]
	String.flatten [ "µ" var " " (Term.show body.term) ]
	
Term.show (Term.self (TermBody.new body.var body.term)) = 
	let var = String.flatten [ "x" (U60.to_string body.var) ]
	String.flatten [ "ξ" var " " (Term.show body.term) ]

// Term.show st (Term.attach String (Term.forall a) s) = s
Term.show (Term.var n) = String.flatten [ "x" (U60.to_string n) ]
Term.show Term.top = "*"
Term.show Term.error = "!"
Term.show (Term.apply a b) = String.flatten [
	"("
	(Term.show a)
	" "
	(Term.show b)
	")"
]
Term.show (Term.check term type) = String.flatten [
	(Term.show term) " : " (Term.show type)
]
Term.show (Term.typeof term) = String.flatten [
	"{" (Term.show term) "}"
]


Program: Term
// CheckProgram: Checker.Result Unit

Main {
	Term.show (Term.lam (Option.some Term.top) (TermBody.new 0 (Term.var 0)))
	//  0 //(Checker.Result.to_string CheckProgram)
}
