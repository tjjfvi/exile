Term: Type

// Real terms
Term.lam (type: Term) (body: Term -> Term): Term
Term.rec (body: Term -> Term): Term
Term.self (body: Term -> Term): Term
Term.apply (fn: Term) (argument: Term): Term

HVM.log <a: Type> <r: Type> (logged: a) (result: r) {
  result
}

// Alias terms
Term.top: Term
Term.bot: Term

// Checker terms
Term.forall (id: U60): Term
Term.instance_bound (instance: Term) (type: Term): Term
Term.subtype_bound (instance: Term) (type: Term): Term
Term.supertype_bound (instance: Term) (type: Term): Term
Term.typeof_bound (instance: Term): Term // Necessary?
Term.error (term: String): Term

State { U60 }
State.set_depth (st: State) (d: U60) { d }
State.get_depth (st: State): U60 { st } 
State.new: State { 0 }
State.new_forall <t> (st: State) (cont: State -> Term -> t): t {
	let old_depth = (State.get_depth st)
	let new_state = (State.set_depth st (+ old_depth 1))
	(cont new_state (Term.forall old_depth))
}

Checker.check (st: State) (term: Term): Bool
Checker.check st Term.top = Bool.true
Checker.check st Term.bot = Bool.false
Checker.check st (Term.apply a b) = (Bool.and
	(Bool.and (Checker.check st a) (Checker.check st b))
	(Checker.instance st a (Term.lam (Term.typeof_bound b) _ => Term.top))
)
Checker.check st (Term.lam t body) =
	State.new_forall st st => x =>
	let x = (Term.instance_bound x t)
	(Checker.check st (body x))
Checker.check st (Term.rec body) = 
	State.new_forall st st => x =>
	let x = (Term.supertype_bound x (Term.rec body))
	(Checker.check st (body x))
Checker.check st (Term.self body) = 
	State.new_forall st st => x =>
	let x = (Term.instance_bound x (Term.self body))
	(Checker.check st (body x))
Checker.check st _ = Bool.true

Checker.instance (st: State) (term: Term) (type: Term): Bool
Checker.instance st term Term.top = Bool.true
Checker.instance st term Term.bot = Bool.false
Checker.instance st a (Term.apply b c) = Checker.reduce_app b c (t => Checker.instance st a t) Bool.false
Checker.instance st (Term.apply a b) c = Checker.reduce_app a b (t => Checker.instance st t c) Bool.false
Checker.instance st Term.top x = Bool.false
Checker.instance st Term.bot x = Bool.false 
Checker.instance st (Term.lam t.type t.body) (Term.lam y.type y.body) = 
	State.new_forall st st => x =>
	let x = (Term.instance_bound x y.type)
	(Bool.and 
		(Checker.subtype st y.type t.type) 
		(Checker.instance st (t.body x) (y.body x))
	)
Checker.instance st (Term.rec body) t = Checker.instance st (body (Term.rec body)) t
Checker.instance st t (Term.rec body) =
	State.new_forall st st => x =>
	let x = (Term.supertype_bound x (Term.rec body))
	Checker.instance st t (body x)
Checker.instance st (Term.self body) type = 
	State.new_forall st st => x =>
	let x = (Term.instance_bound x (Term.self body))
	(Checker.instance
		st
		(body x)
		type
	)
Checker.instance st term (Term.self body)  = 
	(Checker.instance
		st
		term
		(body term)
	)

	
// Extra cases for checker terms
Checker.instance st (Term.instance_bound instance subtype) supertype = Bool.or (Checker.subtype st subtype supertype) (Checker.instance st instance supertype)
Checker.instance st instance (Term.instance_bound type typetype)  = (Checker.instance st instance type)
// Checker.instance st (Term.apply function arg) type =
// todo
Checker.instance st (Term.forall _) type = Bool.false // Nope

Checker.instance st a (Term.apply b c) = 
	Bool.false

// Checker.instance st a b = (HVM.log b Bool.false)


Checker.subtype (st: State) (term: Term) (type: Term): Bool
Checker.subtype st (Term.forall a) (Term.forall b) = (U60.if (== a b) Bool.true Bool.false)
Checker.subtype st term Term.top = Bool.true
Checker.subtype st Term.bot x = Bool.true
Checker.subtype st (Term.subtype_bound _ a) b = Checker.subtype st a b
Checker.subtype st a (Term.supertype_bound _ b) = Checker.subtype st a b
Checker.subtype st (Term.typeof_bound a) b = Checker.instance st a b
Checker.subtype st (Term.supertype_bound a _) b = Checker.subtype st a b
Checker.subtype st a (Term.subtype_bound b _) = Checker.subtype st a b
Checker.subtype st term Term.bot = Bool.false // otherwise we would have already covered it
Checker.subtype st Term.top x = Bool.false 
Checker.subtype st (Term.lam t.type t.body) (Term.lam y.type y.body) = 
	State.new_forall st st => x =>
	let x = (Term.instance_bound x y.type)
	(Bool.and 
		(Checker.subtype st y.type t.type) 
		(Checker.subtype st (t.body x) (y.body x))
	)
Checker.subtype st (Term.rec st.body) (Term.rec sp.body) =
	State.new_forall st st => y =>
	State.new_forall st st => x =>
	(Checker.subtype st (st.body (Term.subtype_bound x y)) (sp.body (Term.supertype_bound y x)))
Checker.subtype st (Term.rec st.body) type =
	(Checker.subtype st (st.body (Term.rec st.body)) type)
Checker.subtype st term (Term.rec sp.body) =
	(Checker.subtype st term (sp.body (Term.rec sp.body)))
Checker.subtype st (Term.self a) (Term.self b) =
	State.new_forall st st => x =>
	let x = (Term.instance_bound x (Term.self a))
	(Checker.subtype st (a x) (b x))
Checker.subtype st (Term.self a) b =
	State.new_forall st st => x =>
	let x = (Term.instance_bound x (Term.self a))
	(Checker.subtype st (a x) b)
Checker.subtype st a (Term.self b) =
	State.new_forall st st => x =>
	let x = (Term.instance_bound x (Term.self a))
	(Checker.subtype st a (b x))
Checker.subtype st (Term.forall a) b = Bool.false

// Extra rules for compiler terms
// (a: b) <= c 
// then (a: b) -> (a: c)
// then a <= c
// the reverse is trivially true since (a: b) only restricts a
Checker.subtype st (Term.instance_bound a b) c = 
	(Checker.subtype st a c)

// Endcase rules
// (a b): c
// (a b): (x: T) (a: x)
// a = (x: T) (a x)
Checker.subtype st (Term.apply a b) c = 
	(Checker.equal st (Term.apply a b) c)

Checker.reduce_app <t> (fn: Term) (arg: Term) (yay: Term -> t) (nay: t): t
Checker.reduce_app t (Term.lam _ f) arg yay nay = yay (f arg)
Checker.reduce_app t (Term.rec f) arg yay nay = (Checker.reduce_app (f (Term.rec f)) arg yay nay)
Checker.reduce_app (Term.instance_bound a b) arg yay nay = yay (Term.instance_bound (Term.apply a arg) (Term.apply b arg))
Checker.reduce_app f arg yay nay = nay

Checker.eval (x: Term): Term
Checker.eval (Term.apply f arg) =
	let f = (Checker.eval f)
	let arg = (Checker.eval arg)
	Checker.reduce_app f arg (t => Checker.eval t) (Term.apply f arg)
Checker.eval (Term.lam type body) = (Term.lam (Checker.eval type) (arg => (Checker.eval (body arg))))
Checker.eval (Term.rec body) = (Term.rec (arg => (Checker.eval (body arg))))
Checker.eval (Term.self body) = (Term.self (arg => (Checker.eval (body arg))))
Checker.eval (Term.instance_bound a Term.top) = (Checker.eval a)
Checker.eval (Term.subtype_bound a Term.top) = (Checker.eval a)
Checker.eval (Term.instance_bound a b) = (Term.instance_bound (Checker.eval a) (Checker.eval b))
Checker.eval (Term.subtype_bound a b) = (Term.subtype_bound (Checker.eval a) (Checker.eval b))
Checker.eval e = e

Checker.equal (st: State) (left: Term) (right: Term): Bool
Checker.equal st (Term.apply a b) (Term.apply c d) = Bool.and (Checker.equal st a c) (Checker.equal st b d) 
Checker.equal st (Term.forall a) (Term.forall b) = (U60.if (== a b) Bool.true Bool.false)
// Two lambdas are equal if they're equal for all x, and their types are equal.
Checker.equal st (Term.lam l.type l.body) (Term.lam r.type r.body) = 
	State.new_forall st st => x =>
	(Bool.and
		(Checker.equal st l.type r.type)
		(Checker.equal st (l.body x) (r.body x))
	)
Checker.equal st (Term.self l.body) (Term.self r.body) = 
	State.new_forall st st => x =>
	(Checker.equal st (l.body x) (r.body x))
Checker.equal st (Term.instance_bound l.instance l.type) (Term.instance_bound r.instance r.type) = 
	(Bool.and
		(Checker.equal st l.instance r.instance)
		(Checker.equal st l.type r.type)
	)
Checker.equal st Term.top Term.top = Bool.true
Checker.equal st Term.bot Term.bot = Bool.true
Checker.equal st (Term.rec l.body) (Term.rec r.body) = 
	State.new_forall st st => x =>
	Checker.equal st (l.body (r.body x)) (r.body (l.body x))
// TODO implement top unrolling


Bool: Type
Bool.true: Bool
Bool.false: Bool
Bool.if <p> (a: Bool) (t: p) (f: p): p
Bool.if p Bool.true t f = t
Bool.if p Bool.false t f = f
U60.if <p> (a: U60) (t: p) (f: p): p
U60.if p 0 t f = f
U60.if p x t f = t

Bool.and (a: Bool) (b: Bool): Bool
Bool.and Bool.true Bool.true = Bool.true
Bool.and a b = Bool.false

Bool.or (a: Bool) (b: Bool): Bool
Bool.or Bool.false Bool.false = Bool.false
Bool.or a b = Bool.true

String: Type
String.cons (a: U60) (b: String): String
String.nil: String

Program: Term

Main {
	(Checker.check State.new Program)
}

// needs HVM from https://github.com/FranchuFranchu/HVM/tree/nodeid
