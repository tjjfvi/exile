Term: Type

// Real terms
Term.lam (type: Term) (body: Term -> Term): Term
Term.rec (body: Term -> Term): Term
Term.self (body: Term -> Term): Term
Term.apply (fn: Term) (argument: Term): Term

HVM.log <a: Type> <r: Type> (logged: a) (result: r) {
  result
}

// Alias terms
Term.top: Term
Term.bot: Term

// Checker terms
Term.forall (id: U60): Term
Term.instance_bound (instance: Term) (type: Term): Term
Term.subtype_bound (instance: Term) (type: Term): Term
Term.typeof_bound (instance: Term): Term // Necessary?
Term.error (term: String): Term
Term.attach <t> (term: Term) (data: t): Term

Checker.Result: Type
Checker.Result.ok: Checker.Result
Checker.Result.err (state: State): Checker.Result

Checker.Result.to_bool (l: Checker.Result): Bool
Checker.Result.to_bool Checker.Result.ok = Bool.true
Checker.Result.to_bool b = Bool.false

Checker.Result.and (l: Checker.Result) (r: Checker.Result): Checker.Result
Checker.Result.and (Checker.Result.err state) r = (Checker.Result.err state)
Checker.Result.and l  (Checker.Result.err state) =  (Checker.Result.err state)
Checker.Result.and l r = Checker.Result.ok

Checker.Result.or (l: Checker.Result) (r: Checker.Result): Checker.Result
Checker.Result.or (Checker.Result.err state) (Checker.Result.err state2) = (Checker.Result.err state)
Checker.Result.or l r = Checker.Result.ok

Checker.Result.to_string (l: Checker.Result): String
Checker.Result.to_string Checker.Result.ok = "Checking successful"
Checker.Result.to_string (Checker.Result.err st) = String.flatten ["Checking not successful. Traceback: " String.newline 
	(State.print_traceback st)
]

Judgement: Type
Judgement.Instance (a: Term) (b: Term): Judgement
Judgement.Equal (a: Term) (b: Term): Judgement
Judgement.Subtype (a: Term) (b: Term): Judgement

Judgement.show (j: Judgement): String
Judgement.show (Judgement.Instance term type) = String.flatten [ (Term.show State.empty term) " : " (Term.show State.empty type) ] 
Judgement.show (Judgement.Equal l r) = String.flatten [ (Term.show State.empty l) " == " (Term.show State.empty r) ] 
Judgement.show (Judgement.Subtype sub sup) = String.flatten [ (Term.show State.empty sub) " <= " (Term.show State.empty sup) ] 

State.Traceback.Entry: Type
State.Traceback.Entry.comment (err: String): State.Traceback.Entry
State.Traceback.Entry.judgement (j: Judgement): State.Traceback.Entry

State.Traceback.Entry.show (entry: State.Traceback.Entry): String
State.Traceback.Entry.show (State.Traceback.Entry.comment msg) = String.flatten [ "// " msg ]
State.Traceback.Entry.show (State.Traceback.Entry.judgement j) = Judgement.show j

State: Type
State.new (depth: U60) (traceback: List State.Traceback.Entry): State

State.empty { State.new 0 List.nil }

State.set_depth (st: State) (d: U60): State
State.set_depth (State.new depth tb) new_depth = (State.new new_depth tb)

State.get_depth (st: State): U60
State.get_depth (State.new depth tb) = depth

State.add_traceback (st: State) (entry: State.Traceback.Entry): State
State.add_traceback (State.new depth traceback) entry = (State.new depth (List.append traceback entry))

State.with_traceback <t> (st: State) (judgement: Judgement) (cont: State -> t): t
State.with_traceback t st judgement cont =
	(cont (State.add_traceback st (State.Traceback.Entry.judgement judgement)))
	
State.with_comment <t> (st: State) (err: String) (cont: State -> t): t
State.with_comment t st err cont =
	(cont (State.add_traceback st (State.Traceback.Entry.comment err)))

State.print_traceback (st: State): String
State.print_traceback (State.new _ List.nil) = ""
State.print_traceback (State.new d (List.cons head tail)) = String.flatten [
	(State.Traceback.Entry.show head)
	String.newline
	(State.print_traceback (State.new d tail))
]


State.new_forall <t> (st: State) (cont: State -> Term -> t): t {
	let old_depth = (State.get_depth st)
	let new_state = (State.set_depth st (+ old_depth 1))
	(cont new_state (Term.forall old_depth))
}


Checker.instance (st: State) (term: Term) (type: Term): Checker.Result {
	State.with_traceback st (Judgement.Instance term type) st =>
	(Checker.instance.go st term type)
}

Checker.instance.go (st: State) (term: Term) (type: Term): Checker.Result
Checker.instance.go st term Term.top = Checker.Result.ok
Checker.instance.go st term Term.bot = 
	State.with_comment st "No term is an instance of the bottom type" st =>
	Checker.Result.err st
Checker.instance.go st Term.top x = 
	State.with_comment st "The top type is only an instance of the top type" st =>
	Checker.Result.err st
Checker.instance.go st Term.bot x = 
	State.with_comment st "The bottom type is only an instance of the top type" st =>
	Checker.Result.err st
Checker.instance.go st (Term.lam t.type t.body) (Term.lam y.type y.body) = 
	State.new_forall st st => x =>
	let x = (Term.instance_bound x y.type)
	(Checker.Result.and 
		(Checker.subtype st y.type t.type) 
		(Checker.instance st (t.body x) (y.body x))
	)
Checker.instance.go st (Term.rec body) t = Checker.instance.go st (body (Term.rec body)) t
Checker.instance.go st t (Term.rec body) = Checker.instance.go st t (body (Term.rec body))
Checker.instance.go st (Term.self body) type = 
	State.new_forall st st => x =>
	let x = (Term.instance_bound x (Term.self body))
	(Checker.instance
		st
		(body x)
		type
	)
Checker.instance.go st term (Term.self body)  = 
	(Checker.instance
		st
		term
		(body term)
	)

	
// Extra cases for checker terms
Checker.instance.go st (Term.instance_bound instance subtype) supertype = Checker.Result.or (Checker.subtype st subtype supertype) (Checker.instance st instance supertype)
Checker.instance.go st instance (Term.instance_bound type typetype)  = (Checker.instance st instance type)
// Checker.instance.go st (Term.apply function arg) type =
// todo
Checker.instance.go st (Term.forall _) type = 
	State.with_comment st "Only the top type is the type of any term" st =>
	Checker.Result.err st // Nope

Checker.instance.go st a (Term.apply b c) = 
	State.with_comment st "Can't decide if a term is an instance of an application" st =>
	Checker.Result.err st

// Checker.instance.go st a b = (HVM.log b Bool.false)

Checker.subtype (st: State) (term: Term) (type: Term): Checker.Result {
	State.with_traceback st (Judgement.Subtype term type) st =>
	(Checker.subtype.go st term type)
}

Checker.subtype.go (st: State) (term: Term) (type: Term): Checker.Result
Checker.subtype.go st (Term.forall a) (Term.forall b) = (U60.if (== a b) Checker.Result.ok 
	(State.with_comment st "These two terms are not equal, so they're not a subtype of each other every time" st =>
	(Checker.Result.err st)))
Checker.subtype.go st term Term.top = Checker.Result.ok
Checker.subtype.go st Term.bot x = Checker.Result.ok
Checker.subtype.go st term Term.bot = Checker.Result.err st // otherwise we would have already covered it
Checker.subtype.go st Term.top x = Checker.Result.err st 
Checker.subtype.go st (Term.lam t.type t.body) (Term.lam y.type y.body) = 
	State.new_forall st st => x =>
	let x = (Term.instance_bound x y.type)
	(Checker.Result.and 
		(Checker.subtype st y.type t.type) 
		(Checker.subtype st (t.body x) (y.body x))
	)
Checker.subtype.go st (Term.rec st.body) (Term.rec sp.body) =
	State.new_forall st st => y =>
	State.new_forall st st => x =>
	let x = (Term.subtype_bound x y)
	(Checker.subtype st (st.body x) (sp.body y))
Checker.subtype.go st (Term.rec st.body) type =
	(Checker.subtype st (st.body (Term.rec st.body)) type)
Checker.subtype.go st term (Term.rec sp.body) =
	(Checker.subtype st term (sp.body (Term.rec sp.body)))
Checker.subtype.go st (Term.forall a) b = 
	State.with_comment st "Only the top type is the supertype of all types" st =>
	Checker.Result.err st

// Extra rules for compiler terms
// (a: b) <= c 
// then (a: b) -> (a: c)
// then a <= c
// the reverse is trivially true since (a: b) only restricts a
Checker.subtype.go st (Term.instance_bound a b) c = 
	(Checker.subtype st a c)

// Endcase rules
// (a b): c
// (a b): (x: T) (a: x)
// a = (x: T) (a x)
Checker.subtype.go st (Term.apply a b) c = 
	State.with_comment st "Can't decide. Falling back to equality." st =>
	(Checker.equal st (Term.apply a b) c)
		




Checker.eval.app (fn: Term) (arg: Term): Term
Checker.eval.app (Term.lam t f) arg = Checker.eval (f arg)
//Checker.eval.app (Term.self f) arg = Checker.eval (f arg)
Checker.eval.app (Term.rec f) arg = Checker.eval (Term.apply (f (Term.rec f)) arg)
Checker.eval.app (Term.instance_bound a b) arg = Checker.eval (Term.instance_bound (Checker.eval (Term.apply a arg)) (Checker.eval (Term.apply b arg)))
Checker.eval.app f arg = (Term.apply f arg)

Checker.eval (x: Term): Term
Checker.eval (Term.apply f arg) = Checker.eval.app (Checker.eval f) (Checker.eval arg)
Checker.eval (Term.lam type body) = (Term.lam (Checker.eval type) (arg => (Checker.eval (body arg))))
Checker.eval (Term.rec body) = (Term.rec (arg => (Checker.eval (body arg))))
Checker.eval (Term.self body) = (Term.self (arg => (Checker.eval (body arg))))
Checker.eval (Term.instance_bound a Term.top) = (Checker.eval a)
Checker.eval (Term.subtype_bound a Term.top) = (Checker.eval a)
Checker.eval (Term.instance_bound a b) = (Term.instance_bound (Checker.eval a) (Checker.eval b))
Checker.eval (Term.subtype_bound a b) = (Term.subtype_bound (Checker.eval a) (Checker.eval b))
Checker.eval e = e

Checker.equal (st: State) (l: Term) (r: Term): Checker.Result {
	State.with_traceback st (Judgement.Equal l r) st =>
	(Checker.equal.go st l r)
}

Checker.equal.go (st: State) (left: Term) (right: Term): Checker.Result
Checker.equal.go st (Term.apply a b) (Term.apply c d) = Checker.Result.and (Checker.equal st a c) (Checker.equal st b d) 
Checker.equal.go st (Term.forall a) (Term.forall b) = (U60.if (== a b) Checker.Result.ok 
	(State.with_comment st "These two terms might not be equal" st =>
	(Checker.Result.err st)))
// Two lambdas are equal if they're equal for all x, and their types are equal.
Checker.equal.go st (Term.lam l.type l.body) (Term.lam r.type r.body) = 
	State.new_forall st st => x =>
	(Checker.Result.and
		(Checker.equal st l.type r.type)
		(Checker.equal st (l.body x) (r.body x))
	)
Checker.equal.go st (Term.self l.body) (Term.self r.body) = 
	State.new_forall st st => x =>
	(Checker.equal st (l.body x) (r.body x))
Checker.equal.go st (Term.instance_bound l.instance l.type) (Term.instance_bound r.instance r.type) = 
	(Checker.Result.and
		(Checker.equal st l.instance r.instance)
		(Checker.equal st l.type r.type)
	)
Checker.equal.go st Term.top Term.top = Checker.Result.ok
Checker.equal.go st Term.bot Term.bot = Checker.Result.ok
Checker.equal.go st (Term.rec l.body) (Term.rec r.body) = 
	State.new_forall st st => x =>
	Checker.equal.go st (l.body (r.body x)) (r.body (l.body x))
Checker.equal.go st a (Term.rec r.body) = 
	Checker.equal.go st a (r.body (Term.rec r.body))
Checker.equal.go st (Term.rec l.body) b =  
	Checker.equal.go st (l.body (Term.rec l.body)) b
Checker.equal.go st a b =
	State.with_comment st "Terms are not equal (or the code for checking this was not implemented)" st =>
	Checker.Result.err st
// TODO implement top unrolling


Bool: Type
Bool.true: Bool
Bool.false: Bool
Bool.if <p> (a: Bool) (t: p) (f: p): p
Bool.if p Bool.true t f = t
Bool.if p Bool.false t f = f
U60.if <p> (a: U60) (t: p) (f: p): p
U60.if p 0 t f = f
U60.if p x t f = t
Bool.and (a: Bool) (b: Bool) { Bool.if a b Bool.false } 
Bool.or (a: Bool) (b: Bool) { Bool.if a Bool.true b }
U60.to_string (n: U60): String
U60.to_string n = (U60.if
	(< n 10)
	(String.cons (+ '0' n) String.nil)
	(String.concat (U60.to_string (/ n 10)) (String.cons (+ '0' (% n 10)) String.nil))
)
Bool.to_string (a: Bool): String
Bool.to_string Bool.true = "Bool.true"
Bool.to_string Bool.false = "Bool.false"
String.newline { String.cons 10 String.nil }



String: Type
String.cons (a: U60) (b: String): String
String.nil: String

List <t>: Type
List.cons <t> (a: t) (b: List t): List t
List.nil <t>: List t

List.append <t> (list: List t) (item: t): List t
List.append t List.nil item = List.cons item List.nil
List.append t (List.cons head tail) item = List.cons head (List.append t tail item)

String.concat (a: String) (b: String): String
String.concat (String.cons a b) c = (String.cons a (String.concat b c))
String.concat String.nil c = c

String.flatten (a: List String): String
String.flatten (List.cons a (List.cons b c)) = (String.flatten (List.cons (String.concat a b) c))
String.flatten (List.cons a List.nil) = a
String.flatten List.nil = ""

Term.show (st: State) (term: Term): String
Term.show st (Term.lam type body) = 
	let type_s = (Term.show st type)
	let var = String.flatten [ "x" (U60.to_string (State.get_depth st)) ]
	State.new_forall st st => x =>
	let x = (Term.attach x var)
	(Bool.if
		(Checker.Result.to_bool (Checker.equal st type Term.top))
		(String.flatten [
			"λ"
			var
			" "
			(Term.show st (body x))
		])
		(String.flatten [
			"λ("
			var
			": "
			type_s
			") "
			(Term.show st (body x))
		])
	)

Term.show st (Term.rec body) = 
	let var = String.flatten [ "x" (U60.to_string (State.get_depth st)) ]
	State.new_forall st st => x =>
	let x = (Term.attach x var)
	String.flatten [
		"µ"
		var
		" "
		(Term.show st (body x))
	]
	
Term.show st (Term.self body) = 
	let var = String.flatten [ "x" (U60.to_string (State.get_depth st)) ]
	State.new_forall st st => x =>
	let x = (Term.attach x var)
	String.flatten [
		"ξ"
		var
		" "
		(Term.show st (body x))
	]

Term.show st (Term.attach String (Term.forall a) s) = s
Term.show st Term.top = "*"
Term.show st Term.bot = "!"
Term.show st (Term.apply a b) = String.flatten [
	"("
	(Term.show st a)
	" "
	(Term.show st b)
	")"
]
Term.show st (Term.forall uid) = String.flatten [
	"any" (U60.to_string uid)
]
Term.show st (Term.instance_bound term type) = String.flatten [
	(Term.show st term) " :: " (Term.show st type)
]
Term.show st (Term.subtype_bound sub sup) = String.flatten [
	(Term.show sub sup) " <= " (Term.show sub sup)
]


	
Main2 {
	let st = State.empty
	State.new_forall st st => t =>
	State.new_forall st st => u =>
	State.new_forall st st => v =>
	let v = (Term.instance_bound v u)
	(Checker.instance
		st
		(Term.lam t (x => v))
		(Term.lam t (x => u))
	)
}

Test.Bool.true: Term
Test.Bool: Term
Test.Unit.new: Term
Test.Unit: Term
Test.Equal: Term
Test.Equal.refl: Term
Test.Equal.refl.type: Term

DebugCheck (a: Term) (b: Term): String {
	let st = State.empty
	String.flatten [
		//(Term.show st a) ": " (Term.show st b) " = " (Checker.Result (Checker.instance st (Checker.eval a) (Checker.eval b)))
	]
}
Sample {
	let st = State.empty

	String.flatten [
		(DebugCheck Test.Bool.true Test.Bool) String.newline
		(DebugCheck Test.Bool.true Test.Unit) String.newline
		(DebugCheck Test.Unit.new Test.Unit) String.newline
		(DebugCheck Test.Unit.new Test.Bool) String.newline
		(DebugCheck Test.Equal.refl Test.Equal.refl.type) String.newline
	]
}

Main3 {
	let st = State.empty
	State.new_forall st st => typ =>
	State.new_forall st st => t =>
	State.new_forall st st => u =>
	let t = (Term.instance_bound t typ)
	let t = (Term.instance_bound u typ)
	(Checker.instance
		State.empty
		(Checker.eval (Term.apply (Term.apply Test.Equal.refl typ) t))
		(Checker.eval (Term.apply (Term.apply (Term.apply Test.Equal typ) t) u))
	)
}

Main4 {
	(Checker.Result.to_string (Checker.instance.go State.empty Test.Bool.true Test.Unit))
}

