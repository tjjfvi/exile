Code.Bool {
	"µ Bool ξ self λ(P: λ(b: Bool) *) λ(tr: (P λp λt λf t)) λ(fl: (P λp λt λf f)) (P self)"
}
Code.Bool.true {
	"@p @t @f t"
}
Code.Unit {
	"%Unit $unit @(proposition: @(p:Unit) *) @(new: (proposition @p @new new)) (proposition unit)"
}
Code.Unit.new {
	"@p @new new"
}
Code.lam_test {
	"@(p: *) p"
}

Code.Unbound {
	"Nat.succ"
}
Code.T {
	"@a @(c: a @a a) a"
}
Main2 {
	do IO {
		ask bool_code = IO.load "../examples/Bool.xil"
		let bool_code = (String.trim (HVM.log bool_code bool_code))
		ask unit_code = IO.load "../examples/Unit.xil"
		let unit_code = (String.trim (HVM.log unit_code unit_code))
		let term_parser = (Exile.HSyntax.parse.term Exile.DepthTable.new)
		ask parsed_bool_code = (Either.match (Parser.run (Exile.Rulebook.parse term_parser) (String.concat bool_code unit_code))
			p => (IO Exile.Rulebook)
			(result => IO.pure result)
			(error => do IO {
				ask IO.output (Parser.Error.match error (x => String) (msg => init => end => msg))
				ask IO.output (String.flatten ["Error" String.new_line])
				return List.nil
			})
		)
		let rulebook = parsed_bool_code
		ask IO.output (Exile.Rulebook.show rulebook)
		let rulebook = (Exile.Rulebook.replace_unbound rulebook)
		ask IO.output (Exile.Rulebook.show rulebook)
		let bool = (Maybe.default (Exile.Rulebook.get_definition rulebook "Bool.not.type") Exile.Term.unbound)
		let bool_true = (Maybe.default (Exile.Rulebook.get_definition rulebook "Bool.not") Exile.Term.unbound)
		//let bool_true = (HVM.log (Exile.HSyntax.show bool_true) bool_true)
		//let bool = (HVM.log (Exile.HSyntax.show bool) bool)
		let cresult = (Exile.Checker.reduce Exile.Checker.empty (Exile.Term.subtype bool_true bool))
		ask IO.output (Exile.CheckResult.show cresult)
		return Unit.new
	}
}

Main3 {
	do IO {
		let term = Code.Unit.new
		let type = Code.T
	
		let type = (Exile.HSyntax.parse type)
		let term = (Exile.HSyntax.parse term)
		let result = Exile.Checker.reduce Exile.Checker.empty (Exile.Term.subtype term type)
		ask IO.output (Exile.CheckResult.show result)
		(IO.done Unit.new)
	}
}


Main4 { (Exile.HSyntax.parse Code.Bool) }

Main5 {
	let a = (Exile.Term.var 0)
	let b = (Exile.Term.var 1)
	let term = (Exile.Term.subtype a b)
	let type = b
	let term = (Exile.Term.infer_lambda (Exile.TermBody.new 10 term))
	let type = (Exile.Term.infer_lambda (Exile.TermBody.new 10 type))
	let res = (Exile.Checker.reduce Exile.Checker.empty (Exile.Term.subtype term type))
	(Exile.CheckResult.show res)
}

Main6 {
	let a = (Exile.Term.infer_lambda (Exile.TermBody.new 1 (Exile.Term.var 1)))
	let a = (Exile.Term.replace_var a 1 3)
	a
}

Main { Main2 } 


