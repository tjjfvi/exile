// Proof that a(bc) = (ab)c
Nat.mul.assoc (a: Nat) (b: Nat) (c: Nat): Equal (Nat.mul a (Nat.mul b c)) (Nat.mul (Nat.mul a b) c)
Nat.mul.assoc Nat.zero     b c = Equal.refl
Nat.mul.assoc (Nat.succ a) b c = 
  // Goal: (a + 1)(bc) = ((a + 1)b)c 
  // Kind2 turns this into a(bc) + bc = (ab + b)c thanks to the definition of Nat.mul

  // Induction gives: a(bc) = (ab)c
  let induction = Nat.mul.assoc a b c

  // c(ab + b) = c(ab) + cb
  let distr_1 = Nat.mul.distr c (Nat.mul a b) b
  // c(ab + b) = (ab + b)c
  let comm_1 = Nat.mul.comm c (Nat.add (Nat.mul a b) b)

  // Proof that a(bc) + bc = c(ab) + cb:
  // c(ab) = (ab)c
  let comm_2 = Nat.mul.comm c (Nat.mul a b)
  // c(ab) = a(bc)
  let chained_1 = Equal.chain comm_2 (Equal.mirror induction)
  // c(ab) + bc = a(bc) + bc
  let chained_1 = Equal.apply (x => Nat.add x (Nat.mul b c)) chained_1

  // bc = cb
  let comm_3 = Nat.mul.comm b c
  // c(ab) + bc = c(ab) + cb
  let comm_3 = Equal.apply (x => Nat.add (Nat.mul c (Nat.mul a b)) x) comm_3
  // a(bc) + bc = c(ab) + cb
  let chained_1 = Equal.chain (Equal.mirror chained_1) comm_3
  // Because c(ab + b) = c(ab) + cb:
  // a(bc) + bc = c(ab + b)
  let chained_1 = Equal.chain chained_1 (Equal.mirror distr_1)
  // Because c(ab + b) = (ab + b)c
  // a(bc) + bc = (ab + b)c
  // This is the goal.
  let chained_1 = Equal.chain chained_1 comm_1

  chained_1
