// Term.top_as_rec : _
(Term.top_as_rec) = (Term.rec @top (Term.lam (Term.bot) @x top))

// Term.bot_as_rec : _
(Term.bot_as_rec) = (Term.rec @bot (Term.lam (Term.top) @x bot))

// Checker.Result.to_bool (l: (Checker.Result)) : (Bool)
(Checker.Result.to_bool (Checker.Result.ok)) = (Bool.true)
(Checker.Result.to_bool b) = (Bool.false)

// Checker.Result.and (l: (Checker.Result)) (r: (Checker.Result)) : (Checker.Result)
(Checker.Result.and (Checker.Result.err state) r) = (Checker.Result.err state)
(Checker.Result.and l (Checker.Result.err state)) = (Checker.Result.err state)
(Checker.Result.and l r) = (Checker.Result.ok)

// Checker.Result.or (l: (Checker.Result)) (r: (Checker.Result)) : (Checker.Result)
(Checker.Result.or (Checker.Result.err state) (Checker.Result.err state2)) = (Checker.Result.err state)
(Checker.Result.or l r) = (Checker.Result.ok)

// Checker.Result.to_string (l: (Checker.Result)) : (String)
(Checker.Result.to_string (Checker.Result.ok)) = "Checking successful"
(Checker.Result.to_string (Checker.Result.err st)) = (String.flatten (List.cons "Checking not successful. Traceback: " (List.cons (String.newline) (List.cons (State.print_traceback st) (List.nil)))))

// Judgement.show (j: (Judgement)) : (String)
(Judgement.show (Judgement.Instance term type)) = (String.flatten (List.cons (Term.show (State.empty) term) (List.cons " : " (List.cons (Term.show (State.empty) type) (List.nil)))))
(Judgement.show (Judgement.Equal l r)) = (String.flatten (List.cons (Term.show (State.empty) l) (List.cons " == " (List.cons (Term.show (State.empty) r) (List.nil)))))
(Judgement.show (Judgement.Subtype sub sup)) = (String.flatten (List.cons (Term.show (State.empty) sub) (List.cons " <= " (List.cons (Term.show (State.empty) sup) (List.nil)))))
(Judgement.show (Judgement.Check term)) = (String.flatten (List.cons "check: " (List.cons (Term.show (State.empty) term) (List.nil))))

// State.Traceback.Entry.show (entry: (State.Traceback.Entry)) : (String)
(State.Traceback.Entry.show (State.Traceback.Entry.comment msg)) = (String.flatten (List.cons "// " (List.cons msg (List.nil))))
(State.Traceback.Entry.show (State.Traceback.Entry.judgement j)) = (Judgement.show j)

// State.empty : _
(State.empty) = (State.new 0 (List.nil))

// State.set_depth (st: (State)) (d: U60) : (State)
(State.set_depth (State.new depth tb) new_depth) = (State.new new_depth tb)

// State.get_depth (st: (State)) : U60
(State.get_depth (State.new depth tb)) = depth

// State.add_traceback (st: (State)) (entry: (State.Traceback.Entry)) (cont: (_: (State)) (Checker.Result)) : (Checker.Result)
(State.add_traceback (State.new depth traceback) entry cont) = (cont (State.new depth (List.append traceback entry)))

// State.with_traceback (st: (State)) (judgement: (Judgement)) (cont: (_: (State)) (Checker.Result)) : (Checker.Result)
(State.with_traceback st judgement cont) = (State.add_traceback st (State.Traceback.Entry.judgement judgement) cont)

// State.with_comment -(t: Type) (st: (State)) (err: (String)) (cont: (_: (State)) t) : t
(State.with_comment st err cont) = (State.add_traceback st (State.Traceback.Entry.comment err) cont)

// State.print_traceback (st: (State)) : (String)
(State.print_traceback (State.new x0_ (List.nil))) = ""
(State.print_traceback (State.new d (List.cons head tail))) = (String.flatten (List.cons (State.Traceback.Entry.show head) (List.cons (String.newline) (List.cons (State.print_traceback (State.new d tail)) (List.nil)))))

// State.new_forall -(t: Type) (st: (State)) (cont: (_: (State)) (_: (Term)) t) : t
(State.new_forall st cont) = let old_depth = (State.get_depth st); let new_state = (State.set_depth st (+ old_depth 1)); ((cont new_state) (Term.forall old_depth))

// Checker.check (st: (State)) (term: (Term)) : (Checker.Result)
(Checker.check st term) = (State.with_traceback st (Judgement.Check term) @st (Checker.check.go st term))

// Checker.check.go (st: (State)) (term: (Term)) : (Checker.Result)
(Checker.check.go st (Term.top)) = (Checker.Result.ok)
(Checker.check.go st (Term.bot)) = (Checker.Result.ok)
(Checker.check.go st (Term.apply a b)) = (Checker.Result.and (Checker.Result.and (Checker.check st a) (Checker.check st b)) (Checker.instance st a (Term.lam (Term.typeof_bound b) @_ (Term.top))))
(Checker.check.go st (Term.lam t body)) = (State.new_forall st @st @x let x = (Term.instance_bound x t); (Checker.check st (body x)))
(Checker.check.go st (Term.rec body)) = (State.new_forall st @st @x let x = (Term.supertype_bound x (Term.rec body)); (Checker.check st (body x)))
(Checker.check.go st (Term.self body)) = (State.new_forall st @st @x let x = (Term.instance_bound x (Term.self body)); (Checker.check st (body x)))
(Checker.check.go st x0_) = (Checker.Result.ok)

// Checker.instance (st: (State)) (term: (Term)) (type: (Term)) : (Checker.Result)
(Checker.instance st term type) = (State.with_traceback st (Judgement.Instance term type) @st (Checker.instance.go st term type))

// Checker.instance.go (st: (State)) (term: (Term)) (type: (Term)) : (Checker.Result)
(Checker.instance.go st term (Term.top)) = (Bool.true)
(Checker.instance.go st a (Term.apply b c)) = (Checker.reduce_app b c @t (Checker.instance st a t) (Checker.Result.err st))
(Checker.instance.go st (Term.apply a b) c) = (Checker.reduce_app a b @t (Checker.instance st t c) (Checker.Result.err st))
(Checker.instance.go st (Term.instance_bound x0_ a) b) = (Checker.subtype st a b)
(Checker.instance.go st term (Term.bot)) = (State.with_comment st "No term is an instance of the bottom type" @st (Checker.Result.err st))
(Checker.instance.go st (Term.top) x) = (State.with_comment st "The top type is only an instance of the top type" @st (Checker.Result.err st))
(Checker.instance.go st (Term.bot) x) = (State.with_comment st "The bottom type is only an instance of the top type" @st (Checker.Result.err st))
(Checker.instance.go st (Term.lam t.type t.body) (Term.lam y.type y.body)) = (State.new_forall st @st @x let x = (Term.instance_bound x y.type); (Checker.Result.and (Checker.subtype st y.type t.type) (Checker.instance st (t.body x) (y.body x))))
(Checker.instance.go st (Term.rec body) t) = (Checker.instance st (body (Term.rec body)) t)
(Checker.instance.go st t (Term.rec body)) = (State.new_forall st @st @x let x = (Term.supertype_bound x (Term.rec body)); (Checker.instance st t (body x)))
(Checker.instance.go st (Term.self body) type) = (State.new_forall st @st @x let x = (Term.instance_bound x (Term.self body)); (Checker.instance st (body x) type))
(Checker.instance.go st term (Term.self body)) = (Checker.instance st term (body term))
(Checker.instance.go st (Term.instance_bound instance subtype) supertype) = (Checker.Result.or (Checker.subtype st subtype supertype) (Checker.instance st instance supertype))
(Checker.instance.go st instance (Term.instance_bound type typetype)) = (Checker.instance st instance type)
(Checker.instance.go st (Term.forall x1_) type) = (State.with_comment st "Only the top type is the type of any term" @st (Checker.Result.err st))
(Checker.instance.go st a (Term.apply b c)) = (State.with_comment st (String.cons 67 (String.cons 97 (String.cons 110 (String.cons 39 "t decide if a term is an instance of an application")))) @st (Checker.Result.err st))

// Checker.subtype (st: (State)) (term: (Term)) (type: (Term)) : (Checker.Result)
(Checker.subtype st term type) = (State.with_traceback st (Judgement.Subtype term type) @st (Checker.subtype.go st term type))

// Checker.subtype.go (st: (State)) (term: (Term)) (type: (Term)) : (Checker.Result)
(Checker.subtype.go st (Term.forall a) (Term.forall b)) = (U60.if (== a b) (Checker.Result.ok) (State.with_comment st (String.cons 84 (String.cons 104 (String.cons 101 (String.cons 115 (String.cons 101 (String.cons 32 (String.cons 116 (String.cons 119 (String.cons 111 (String.cons 32 (String.cons 116 (String.cons 101 (String.cons 114 (String.cons 109 (String.cons 115 (String.cons 32 (String.cons 97 (String.cons 114 (String.cons 101 (String.cons 32 (String.cons 110 (String.cons 111 (String.cons 116 (String.cons 32 (String.cons 101 (String.cons 113 (String.cons 117 (String.cons 97 (String.cons 108 (String.cons 44 (String.cons 32 (String.cons 115 (String.cons 111 (String.cons 32 (String.cons 116 (String.cons 104 (String.cons 101 (String.cons 121 (String.cons 39 "re not a subtype of each other every time"))))))))))))))))))))))))))))))))))))))) @st (Checker.Result.err st)))
(Checker.subtype.go st term (Term.top)) = (Bool.true)
(Checker.subtype.go st (Term.bot) x) = (Bool.true)
(Checker.subtype.go st (Term.subtype_bound x0_ a) b) = (Checker.subtype st a b)
(Checker.subtype.go st a (Term.supertype_bound x1_ b)) = (Checker.subtype st a b)
(Checker.subtype.go st (Term.typeof_bound a) b) = (Checker.instance st a b)
(Checker.subtype.go st (Term.supertype_bound a x2_) b) = (Checker.subtype st a b)
(Checker.subtype.go st a (Term.subtype_bound b x3_)) = (Checker.subtype st a b)
(Checker.subtype.go st term (Term.bot)) = (Bool.false)
(Checker.subtype.go st (Term.top) x) = (Bool.false)
(Checker.subtype.go st (Term.lam t.type t.body) (Term.lam y.type y.body)) = (State.new_forall st @st @x let x = (Term.instance_bound x y.type); (Checker.Result.and (Checker.subtype st y.type t.type) (Checker.subtype st (t.body x) (y.body x))))
(Checker.subtype.go st (Term.rec st.body) (Term.rec sp.body)) = (State.new_forall st @st @y (State.new_forall st @st @x (Checker.subtype st (st.body (Term.subtype_bound x y)) (sp.body (Term.supertype_bound y x)))))
(Checker.subtype.go st (Term.rec st.body) type) = (Checker.subtype st (st.body (Term.rec st.body)) type)
(Checker.subtype.go st term (Term.rec sp.body)) = (Checker.subtype st term (sp.body (Term.rec sp.body)))
(Checker.subtype.go st (Term.self a) (Term.self b)) = (State.new_forall st @st @x let x = (Term.instance_bound x (Term.self a)); (Checker.subtype st (a x) (b x)))
(Checker.subtype.go st (Term.self a) b) = (State.new_forall st @st @x let x = (Term.instance_bound x (Term.self a)); (Checker.subtype st (a x) b))
(Checker.subtype.go st a (Term.self b)) = (State.new_forall st @st @x let x = (Term.instance_bound x (Term.self a)); (Checker.subtype st a (b x)))
(Checker.subtype.go st (Term.forall a) b) = (State.with_comment st "Only the top type is the supertype of all types" @st (Checker.Result.err st))
(Checker.subtype.go st (Term.instance_bound a b) c) = (Checker.subtype st a c)
(Checker.subtype.go st (Term.apply a b) c) = (State.with_comment st (String.cons 67 (String.cons 97 (String.cons 110 (String.cons 39 "t decide. Falling back to equality.")))) @st (Checker.equal st (Term.apply a b) c))

// Checker.reduce_app -(t: Type) (fn: (Term)) (arg: (Term)) (yay: (_: (Term)) t) (nay: t) : t
(Checker.reduce_app (Term.lam x0_ f) arg yay nay) = (yay (f arg))
(Checker.reduce_app (Term.rec f) arg yay nay) = (Checker.reduce_app (f (Term.rec f)) arg yay nay)
(Checker.reduce_app (Term.instance_bound a b) arg yay nay) = (yay (Term.instance_bound (Term.apply a arg) (Term.apply b arg)))
(Checker.reduce_app f arg yay nay) = nay

// Checker.eval (x: (Term)) : (Term)
(Checker.eval (Term.apply f arg)) = let f = (Checker.eval f); let arg = (Checker.eval arg); (Checker.reduce_app f arg @t (Checker.eval t) (Term.apply f arg))
(Checker.eval (Term.lam type body)) = (Term.lam (Checker.eval type) @arg (Checker.eval (body arg)))
(Checker.eval (Term.rec body)) = (Term.rec @arg (Checker.eval (body arg)))
(Checker.eval (Term.self body)) = (Term.self @arg (Checker.eval (body arg)))
(Checker.eval (Term.instance_bound a (Term.top))) = (Checker.eval a)
(Checker.eval (Term.subtype_bound a (Term.top))) = (Checker.eval a)
(Checker.eval (Term.instance_bound a b)) = (Term.instance_bound (Checker.eval a) (Checker.eval b))
(Checker.eval (Term.subtype_bound a b)) = (Term.subtype_bound (Checker.eval a) (Checker.eval b))
(Checker.eval e) = e

// Checker.equal (st: (State)) (l: (Term)) (r: (Term)) : (Checker.Result)
(Checker.equal st l r) = (State.with_traceback st (Judgement.Equal l r) @st (Checker.equal.go st l r))

// Checker.equal.go (st: (State)) (left: (Term)) (right: (Term)) : (Checker.Result)
(Checker.equal.go st (Term.apply a b) (Term.apply c d)) = (Checker.Result.and (Checker.equal st a c) (Checker.equal st b d))
(Checker.equal.go st (Term.forall a) (Term.forall b)) = (U60.if (== a b) (Checker.Result.ok) (State.with_comment st "These two terms might not be equal" @st (Checker.Result.err st)))
(Checker.equal.go st (Term.lam l.type l.body) (Term.lam r.type r.body)) = (State.new_forall st @st @x (Checker.Result.and (Checker.equal st l.type r.type) (Checker.equal st (l.body x) (r.body x))))
(Checker.equal.go st (Term.self l.body) (Term.self r.body)) = (State.new_forall st @st @x (Checker.equal st (l.body x) (r.body x)))
(Checker.equal.go st (Term.instance_bound l.instance l.type) (Term.instance_bound r.instance r.type)) = (Checker.Result.and (Checker.equal st l.instance r.instance) (Checker.equal st l.type r.type))
(Checker.equal.go st (Term.top) (Term.top)) = (Checker.Result.ok)
(Checker.equal.go st (Term.bot) (Term.bot)) = (Checker.Result.ok)
(Checker.equal.go st (Term.top) (Term.bot)) = (Checker.Result.err "* != !")
(Checker.equal.go st (Term.bot) (Term.top)) = (Checker.Result.err "* != !")
(Checker.equal.go st (Term.top) a) = (Checker.equal st (Term.top_as_rec) a)
(Checker.equal.go st a (Term.top)) = (Checker.equal st a (Term.top_as_rec))
(Checker.equal.go st (Term.bot) a) = (Checker.equal st (Term.bot_as_rec) a)
(Checker.equal.go st a (Term.bot)) = (Checker.equal st a (Term.bot_as_rec))
(Checker.equal.go st (Term.rec l.body) (Term.rec r.body)) = (State.new_forall st @st @x (Checker.equal.go st (l.body (r.body x)) (r.body (l.body x))))
(Checker.equal.go st a (Term.rec r.body)) = (Checker.equal.go st a (r.body (Term.rec r.body)))
(Checker.equal.go st (Term.rec l.body) b) = (Checker.equal.go st (l.body (Term.rec l.body)) b)
(Checker.equal.go st a b) = (State.with_comment st "Terms are not equal (or the code for checking this was not implemented)" @st (Checker.Result.err st))

// Bool.if -(p: Type) (a: (Bool)) (t: p) (f: p) : p
(Bool.if (Bool.true) t f) = t
(Bool.if (Bool.false) t f) = f

// U60.if -(p: Type) (a: U60) (t: p) (f: p) : p
(U60.if 0 t f) = f
(U60.if x t f) = t

// Bool.and (a: (Bool)) (b: (Bool)) : _
(Bool.and a b) = (Bool.if a b (Bool.false))

// Bool.or (a: (Bool)) (b: (Bool)) : _
(Bool.or a b) = (Bool.if a (Bool.true) b)

// U60.to_string (n: U60) : (String)
(U60.to_string n) = (U60.if (< n 10) (String.cons (+ 48 n) "") (String.concat (U60.to_string (/ n 10)) (String.cons (+ 48 (% n 10)) "")))

// Bool.to_string (a: (Bool)) : (String)
(Bool.to_string (Bool.true)) = "Bool.true"
(Bool.to_string (Bool.false)) = "Bool.false"

// String.newline : _
(String.newline) = (String.cons 10 "")

// List.append -(t: Type) (list: (List t)) (item: t) : (List t)
(List.append (List.nil) item) = (List.cons item (List.nil))
(List.append (List.cons head tail) item) = (List.cons head (List.append tail item))

// List.len -(t: Type) (list: (List t)) : U60
(List.len (List.nil)) = 0
(List.len (List.cons x1_ l)) = (+ (List.len l) 1)

// String.concat (a: (String)) (b: (String)) : (String)
(String.concat (String.cons a b) c) = (String.cons a (String.concat b c))
(String.concat "" c) = c

// String.flatten (a: (List (String))) : (String)
(String.flatten (List.cons a (List.cons b c))) = (String.flatten (List.cons (String.concat a b) c))
(String.flatten (List.cons a (List.nil))) = a
(String.flatten (List.nil)) = ""

// Term.show (st: (State)) (term: (Term)) : (String)
(Term.show st (Term.lam type body)) = let type_s = (Term.show st type); let var = (String.flatten (List.cons "x" (List.cons (U60.to_string (State.get_depth st)) (List.nil)))); (State.new_forall st @st @x let x = (Term.attach x var); (Bool.if (Checker.Result.to_bool (Checker.equal st type (Term.top))) (String.flatten (List.cons (String.cons 955 "") (List.cons var (List.cons " " (List.cons (Term.show st (body x)) (List.nil)))))) (String.flatten (List.cons (String.cons 955 "(") (List.cons var (List.cons ": " (List.cons type_s (List.cons ") " (List.cons (Term.show st (body x)) (List.nil))))))))))
(Term.show st (Term.rec body)) = let var = (String.flatten (List.cons "x" (List.cons (U60.to_string (State.get_depth st)) (List.nil)))); (State.new_forall st @st @x let x = (Term.attach x var); (String.flatten (List.cons (String.cons 181 "") (List.cons var (List.cons " " (List.cons (Term.show st (body x)) (List.nil)))))))
(Term.show st (Term.self body)) = let var = (String.flatten (List.cons "x" (List.cons (U60.to_string (State.get_depth st)) (List.nil)))); (State.new_forall st @st @x let x = (Term.attach x var); (String.flatten (List.cons (String.cons 958 "") (List.cons var (List.cons " " (List.cons (Term.show st (body x)) (List.nil)))))))
(Term.show st (Term.attach (Term.forall a) s)) = s
(Term.show st (Term.top)) = "*"
(Term.show st (Term.bot)) = "!"
(Term.show st (Term.apply a b)) = (String.flatten (List.cons "(" (List.cons (Term.show st a) (List.cons " " (List.cons (Term.show st b) (List.cons ")" (List.nil)))))))
(Term.show st (Term.forall uid)) = (String.flatten (List.cons "any" (List.cons (U60.to_string uid) (List.nil))))
(Term.show st (Term.instance_bound term type)) = (String.flatten (List.cons (Term.show st term) (List.cons " :: " (List.cons (Term.show st type) (List.nil)))))
(Term.show st (Term.subtype_bound sub sup)) = (String.flatten (List.cons (Term.show sub sup) (List.cons " <= " (List.cons (Term.show sub sup) (List.nil)))))
(Term.show st (Term.supertype_bound sub sup)) = (String.flatten (List.cons (Term.show sub sup) (List.cons " >= " (List.cons (Term.show sub sup) (List.nil)))))
(Term.show st (Term.typeof_bound term)) = (String.flatten (List.cons "typeof " (List.cons (Term.show st term) (List.nil))))

// Main : _
(Main) = (Checker.Result.to_string (Checker.check (State.empty) (Checker.eval (Program))))

Program =
let vEqual = (Term.apply (Term.lam Term.top @v v) (Term.lam Term.top @vT (Term.lam vT @vx (Term.lam vT @vy (Term.lam (Term.lam vT @vx Term.top) @vP (Term.lam (Term.apply vP vx) @va (Term.apply vP vy)))))));
let vEqual.refl = (Term.apply (Term.lam Term.top @v v) (Term.lam Term.top @vT (Term.lam vT @vx (Term.lam (Term.lam vT @vx Term.top) @vP (Term.lam (Term.apply vP vx) @va va)))));
let vEqual.comm = (Term.apply (Term.lam (Term.lam Term.top @vT (Term.lam vT @vx (Term.lam vT @vy (Term.lam (Term.apply (Term.apply (Term.apply vEqual vT) vx) vy) @vp (Term.apply (Term.apply (Term.apply vEqual vT) vy) vx))))) @v v) (Term.lam Term.top @vT (Term.lam vT @vx (Term.lam vT @vy (Term.lam (Term.apply (Term.apply (Term.apply vEqual vT) vx) vy) @vp (Term.apply (Term.apply vp (Term.lam vT @vn (Term.apply (Term.apply (Term.apply vEqual vT) vn) vx))) (Term.apply (Term.apply vEqual.refl vT) vx)))))));
let vEqual.trans = (Term.apply (Term.lam (Term.lam Term.top @vT (Term.lam vT @vx (Term.lam vT @vy (Term.lam vT @vz (Term.lam (Term.apply (Term.apply (Term.apply vEqual vT) vx) vy) @vp (Term.lam (Term.apply (Term.apply (Term.apply vEqual vT) vy) vz) @vq (Term.apply (Term.apply (Term.apply vEqual vT) vx) vz))))))) @v v) (Term.lam Term.top @vT (Term.lam vT @vx (Term.lam vT @vy (Term.lam vT @vz (Term.lam (Term.apply (Term.apply (Term.apply vEqual vT) vx) vy) @vp (Term.lam (Term.apply (Term.apply (Term.apply vEqual vT) vy) vz) @vq (Term.apply (Term.apply vq (Term.lam vT @vn (Term.apply (Term.apply (Term.apply vEqual vT) vx) vn))) vp))))))));
let vBool = (Term.apply (Term.lam Term.top @v v) (Term.rec @vBool (Term.self @vself (Term.lam (Term.lam vBool @vb Term.top) @vP (Term.lam (Term.apply vP (Term.lam Term.top @vp (Term.lam Term.top @vt (Term.lam Term.top @vf vt)))) @vt (Term.lam (Term.apply vP (Term.lam Term.top @vp (Term.lam Term.top @vt (Term.lam Term.top @vf vf)))) @vf (Term.apply vP vself)))))));
let vBool.true = (Term.apply (Term.lam Term.top @v v) (Term.lam Term.top @vp (Term.lam Term.top @vt (Term.lam Term.top @vf vt))));
let vBool.false = (Term.apply (Term.lam Term.top @v v) (Term.lam Term.top @vp (Term.lam Term.top @vt (Term.lam Term.top @vf vf))));
let vBool.not = (Term.apply (Term.lam Term.top @v v) (Term.lam vBool @vx (Term.apply (Term.apply (Term.apply vx (Term.lam Term.top @v_ vBool)) vBool.false) vBool.true)));
let vBool.and = (Term.apply (Term.lam Term.top @v v) (Term.lam vBool @vx (Term.lam vBool @vy (Term.apply (Term.apply (Term.apply vx (Term.lam Term.top @v_ vBool)) vy) vBool.false))));
let vBool.or = (Term.apply (Term.lam Term.top @v v) (Term.lam vBool @vx (Term.lam vBool @vy (Term.apply (Term.apply (Term.apply vx (Term.lam Term.top @v_ vBool)) vBool.true) vy))));
let vBool.not_not = (Term.apply (Term.lam Term.top @v v) (Term.lam vBool @vx (Term.apply (Term.apply (Term.apply vx (Term.lam vBool @vx (Term.apply (Term.apply vEqual (Term.apply vBool.not (Term.apply vBool.not vx))) vx))) (Term.apply (Term.apply vEqual.refl vBool) vBool.true)) (Term.apply (Term.apply vEqual.refl vBool) vBool.false))));
let vBool.and_true = (Term.apply (Term.lam Term.top @v v) (Term.lam vBool @vx (Term.apply (Term.apply (Term.apply vx (Term.lam vBool @vx (Term.apply (Term.apply vEqual (Term.apply (Term.apply vBool.and vx) vBool.true)) vx))) (Term.apply (Term.apply vEqual.refl vBool) vBool.true)) (Term.apply (Term.apply vEqual.refl vBool) vBool.false))));
let vBool.or_false = (Term.apply (Term.lam Term.top @v v) (Term.lam vBool @vx (Term.apply (Term.apply (Term.apply vx (Term.lam vBool @vx (Term.apply (Term.apply vEqual (Term.apply (Term.apply vBool.or vx) vBool.false)) vx))) (Term.apply (Term.apply vEqual.refl vBool) vBool.true)) (Term.apply (Term.apply vEqual.refl vBool) vBool.false))));
let vBool.and_false = (Term.apply (Term.lam Term.top @v v) (Term.lam vBool @vx (Term.apply (Term.apply (Term.apply vx (Term.lam vBool @vx (Term.apply (Term.apply vEqual (Term.apply (Term.apply vBool.and vx) vBool.false)) vBool.false))) (Term.apply (Term.apply vEqual.refl vBool) vBool.false)) (Term.apply (Term.apply vEqual.refl vBool) vBool.false))));
let vBool.or_true = (Term.apply (Term.lam Term.top @v v) (Term.lam vBool @vx (Term.apply (Term.apply (Term.apply vx (Term.lam vBool @vx (Term.apply (Term.apply vEqual (Term.apply (Term.apply vBool.or vx) vBool.true)) vBool.true))) (Term.apply (Term.apply vEqual.refl vBool) vBool.true)) (Term.apply (Term.apply vEqual.refl vBool) vBool.true))));
(Term.apply vBool.and vBool.true)
